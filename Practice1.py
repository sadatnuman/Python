# -*- coding: utf-8 -*-
"""Lab 02 Basic_Python_Data_Structure.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/123IrOAn-TFiM0n3gtGNzEjSZhDRs1bMJ

# About this notebook
<p style="text-align: justify"> Here, you will learn the basic coding and data structures including numbers, strings, list, dictionaries and more. Some codes already done for demonstration. Some other codes, you will do as excercises.</p>

## Submission
<p style="text-align: justify">After completing the practice codes and exercises, download the notebook (.pynb file) and submit the notebook  to MS Teams inbox in the class period</p>
<p> 1.<b> You must submit your own code</b>. If similarity found negative marking will be given.</p>
<p> 2. Modify the file name writing ID at the beigining of the file name. </p><p><b>Example: 20-45961-3 Lab 01.ipynb</b></p>
<p> 3. Other file format (except .pynb) or link will not be accepted.</p>

# Number

**Basic Arithmetic Operations**
"""

# Addition, Subtraction, Multiplication, Division
a = 10
b = 5

sum_result = a + b
difference_result = a - b
product_result = a * b
division_result = a / b

print(f"Sum: {sum_result}, Difference: {difference_result}, Product: {product_result}, Division: {division_result}")

"""**Exponentiation and Modulus**"""

# Exponentiation (Power) and Modulus (Remainder)
base = 2
exponent = 3

power_result = base ** exponent
modulus_result = a % b

print(f"Power: {power_result}, Modulus: {modulus_result}")

"""**Floor Division**"""

# Floor Division
floor_result = a // b   # floored division result

print(f"Floor Division: {floor_result}")

"""**Absolute Value and Rounding**"""

# Absolute Value and Rounding
negative_number = -7.5

absolute_value = abs(negative_number)
rounded_value = round(negative_number)

print(f"Absolute Value: {absolute_value}, Rounded Value: {rounded_value}")

"""**Using the math module for advanced number operations**"""

import math

# Square root, Factorial, and Trigonometric functions
square_root = math.sqrt(16)
factorial_result = math.factorial(5)
sin_value = math.sin(math.radians(30))

print(f"Square Root: {square_root}, Factorial: {factorial_result}, sin(30 degrees): {sin_value}")

"""**Random Number Generation**"""

import random

# Generate a random number between 1 and 100
random_number = random.randint(1, 100)
print(f"Random Number: {random_number}")

# Generate a random float between 0 and 1
random_float = random.random()
print(f"Random Float: {random_float}")

"""<b>Note:</b> A cell in Python will only display the value of the last expression. If you want to output other values, you should use the *print()* function.

# Object types
The basic object types are Numbers, Strings, Lists, Dictionaries, Tuples, Files and Other types (Sets, types, None, Booleans etc.)

**Integer and Float**
"""

a=10.5
b=6

# Checking the type of an object
print(type(a))
print(type(b))

"""**String**"""

# Concatenation
greeting = "Hello, "
name = "Alice"
message = greeting + name  # Combine strings
print(message)

# Repetition
repeat_string = "Hi! " * 3
print(repeat_string)

# Slicing
text = "Hello, World!"
substring = text[7:12]  # Extract substring
print(substring)

# Changing case
text = "hello"
upper_case = text.upper()  # Convert to uppercase
lower_case = text.lower()  # Convert to lowercase
print(upper_case)
print(lower_case)

# Stripping whitespace
text = "   Hello, World!   "
stripped_text = text.strip()  # Removes spaces from both ends
print(stripped_text)

# Finding substring
text = "Hello, World!"
index = text.find("World")  # Returns the index where "substring" starts
print(index)

# Replacing substring
text = "Hello, World!"
new_text = text.replace("World", "Python")
print(new_text)

# Checking substring existence
text = "Hello, World!"
contains_hello = "Hello" in text
contains_python = "Python" in text
print(contains_hello)
print(contains_python)

# String length
text = "Hello, World!"
length = len(text)
print(length)

# Splitting string
text = "apple,banana,orange"
fruits = text.split(",")  # Split by comma
print(fruits)

# Joining strings
fruits = ['apple', 'banana', 'orange']
joined_fruits = ", ".join(fruits)
print(joined_fruits)

# String formatting
name = "Alice"
age = 25
formatted_string = f"My name is {name} and I am {age} years old."
print(formatted_string)

# Checking start or end
text = "Hello, World!"
starts_with_hello = text.startswith("Hello")
ends_with_world = text.endswith("World!")
print(starts_with_hello)
print(ends_with_world)

# Counting occurrences
text = "banana"
count_a = text.count("a")
print(count_a)

# Checking if alphabetic
text = "Hello"
is_alpha = text.isalpha()
print(is_alpha)

text = "Hello123"
is_alpha = text.isalpha()
print(is_alpha)

# Negative index example
text = "Hello, World!"
last_char = text[-1]  # Last character
print(last_char)

# Negative index slicing
substring = text[-6:-1]
print(substring)

# Reversing string
reversed_text = text[::-1]  # Reverse the entire string
print(reversed_text)

# Slicing with negative step
reversed_substring = text[-7:-1:2]  # Start from index -7, stop at index -1, step by 2
print(reversed_substring)

"""**List**"""

# Creating a list
fruits = ["apple", "banana", "cherry"]
print(fruits)

# Accessing list elements
first_fruit = fruits[0]
print(first_fruit)

last_fruit = fruits[-1]  # Last element
print(last_fruit)

"""Like strings (and all other built-in sequence types), lists can be indexed and sliced:"""

# Slicing a list
sublist = fruits[1:3]  # Elements from index 1 to 2
print(sublist)

# Appending an element
fruits.append("orange")
print(fruits)

# Inserting an element
fruits.insert(1, "grape")  # Insert "grape" at index 1
print(fruits)

# Removing by value
fruits.remove("banana")
print(fruits)

# Removing by index
removed_fruit = fruits.pop(2)  # Removes element at index 2
print(removed_fruit)
print(fruits)

# Finding the index of an element
index_of_grape = fruits.index("grape")
print(index_of_grape)

# Checking existence of an element
exists = "apple" in fruits
print(exists)

exists = "banana" in fruits
print(exists)

# Getting the length of the list
length = len(fruits)
print(length)

# Sorting a list
fruits = ["orange", "banana", "apple", "grape"]
fruits.sort()
print(fruits)

# Reversing a list
fruits.reverse()
print(fruits)

# List comprehension
numbers = [1, 2, 3, 4, 5]
squared_numbers = [n ** 2 for n in numbers]
print(squared_numbers)

# Extending a list
more_fruits = ["kiwi", "melon"]
fruits.extend(more_fruits)
print(fruits)

# List with different data types in nested lists
mixed_nested_list = [[1, "apple", 3.14], [True, "banana", None], [False, 42, "hello"]]

# Accessing elements
print(mixed_nested_list[0])
print(mixed_nested_list[1][1])
print(mixed_nested_list[2][2])

# Modifying an element in the nested list
mixed_nested_list[2][0] = True
print(mixed_nested_list)

"""Lists also support operations like concatenation"""

# Two lists to concatenate
list1 = [1, 2, 3]
list2 = [4, 5, 6]

# Concatenating the lists
result = list1 + list2
print(result)  # Output: [1, 2, 3, 4, 5, 6]

"""**Dictionary**
<p style="text-align: justify">Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys.</p>

<p style="text-align: justify">It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: {}. Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output.</p>
"""

# Using curly braces
person = {"name": "John", "age": 25, "city": "New York"}

# Using dict() constructor
person2 = dict(name="Jane", age=30, city="Los Angeles")

print(person)

# Accessing a value using a key
print(person["name"])
print(person2["age"])

# Using get() method (safe way to access values)
print(person.get("city"))
print(person.get("country", "Not found"))

# Adding a new key-value pair
person["country"] = "USA"
print(person)

# Updating an existing key-value pair
person["age"] = 26
print(person)

# Using del to remove a key-value pair
del person["city"]
print(person)

# Using pop() to remove a key-value pair and get the value
age = person.pop("age")
print(person)
print(age)

# Using popitem() to remove and return the last key-value pair
last_item = person.popitem()
print(person)
print(last_item)

# Checking if a key exists
print("name" in person)
print("age" in person)

# Iterating over keys
for key in person:
    print(key)

# Iterating over values
for value in person.values():
    print(value)

# Iterating over key-value pairs
for key, value in person.items():
    print(key, value)

"""**Tuples and Sets**
<br>Use the content from [here](https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences) to follow some examples on tuple and set.
"""

fruits = ("apple", "banana", "mango")
print("First fruit in tuple:", fruits[0])

colors = {"red", "green", "blue", "red"}
print("Colors in set:", colors)

"""<b> Exercise 1:</b> Implement stack using list
<p><b>Hints:</b> The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use append(). To retrieve an item from the top of the stack, use pop() without an explicit index</p>
"""

stack = []

stack.append('A')
stack.append('B')
stack.append('C')

print(stack)

x = stack.pop()
print("Popped:", x)

print(stack)

if stack:
    print("Top:", stack[-1])
else:
    print("Stack is empty")

print("Size:", len(stack))

"""<b> Exercise 2:</b> Implement queue using list
<p><b>Hints:</b> It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”)</p>
"""

class Queue:
    def __init__(self):
        self.queue = []

    def enqueue(self, item):
        self.queue.append(item)
        print(f"{item} added to the queue.")

    def dequeue(self):
        if not self.is_empty():
            item = self.queue.pop(0)
            print(f"{item} removed from the queue.")
            return item
        else:
            print("Queue is empty.")
            return None

    def peek(self):
        if not self.is_empty():
            return self.queue[0]
        else:
            print("Queue is empty.")
            return None

    def is_empty(self):
        return len(self.queue) == 0

    def size(self):
        return len(self.queue)

    def display(self):
        print("Current Queue:", self.queue)

my_queue = Queue()
my_queue.enqueue("Apple")
my_queue.enqueue("Banana")
my_queue.enqueue("Cherry")
my_queue.display()

my_queue.dequeue()
my_queue.display()

print("Front of queue:", my_queue.peek())
print("Is queue empty?", my_queue.is_empty())
print("Size of queue:", my_queue.size())

"""<b> Exercise 3:</b> Define a dictionary to store the details of 3 persons. Also, print some data from the dictionary.
 <p><b>Hint:</b> You may require nesting dictionary, lists, string inside the dictionary.</p>
"""

people = {
    "people1": {
        "name": "Nazmus",
        "age": 20,
        "hobbies": ["reading", "painting"],
        "city": "Dhaka"
    },
    "people2": {
        "name": "Sadat",
        "age": 21,
        "hobbies": ["cycling", "gaming"],
        "city": "Rajbari"
    },
    "people3": {
        "name": "Numan",
        "age": 22,
        "hobbies": ["music", "traveling"],
        "city": "Pangsha"
    }
}

print("Name of people1:", people["people1"]["name"])
print("Age of people2:", people["people2"]["age"])
print("Hobbies of people3:", people["people3"]["hobbies"])
print("City of people1:", people["people1"]["city"])

"""# You may add more examples by yourself below"""

#CODE